---
title: 'Past, Present, and Future of React State Management'
author: 'Brown'
publishedOn: 'May 11, 2012'
description: 'Before we begin, its critical you understand some of the terms commonly used. These arent the canonical names.'
cover: '/static/images/vladimir-malyutin-FNlcrR40Q3o-unsplash.jpg'
---

# Server Caching State

In the early days of React, lots of state management boiled down to fetching data from APIs and caching it for use across the application. The community leaned heavily on libraries like Redux because there wasn't an easy, widely used way to manage just the server cache state.

> With the release of React Hooks, encapsulating logic into shared hooks became much easier and accessible. Libraries like SWR and React Query emerged to solve this problem specifically.

You might think "Why have a separate library just for server caching state?". Well, caching is hard. Server caching state solves different problems than UI state. Here's a shortlist of some of the things these libraries handle for you:

- Polling on interval
- Revalidation on focus
- Revalidation on network recovery
- Local mutation (Optimistic UI)
- Smart error retrying
- Pagination and scroll position recovery
- Do you want to implement those yourself? Probably not.



##  React Context

With v16.3, React Context gave us a first-party solution to share logic between components.
This also prevented passing values down as props through multiple levels of nested components (i.e. "prop-drilling").